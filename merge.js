// Generated by CoffeeScript 1.3.3
var ang, basictree, c, canvas, combinations, cx, cy, divideQuadrants, e, getPixel, h, h1, h2, i, j, parts, pixels, rand, recursion, reference, rng_state, s, seed, size, smallBoundingBox, w, w1, w2, waste1, waste2, weightMerger, x, x1, x2, y, y1, y2, _i, _j, _k, _l, _len, _len1, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;

canvas = document.getElementById('c');

c = canvas.getContext('2d');

size = 2048;

canvas.width = canvas.height = size;

seed = Math.floor(Math.random() * 0x100000000);

rng_state = seed;

rand = function() {
  return Math.random();
  rng_state = (1103515245 * rng_state + 12345) % 0x100000000;
  return rng_state / 0x100000000;
};

c.fillStyle = '#007fff';

for (i = _i = 0; _i < 100; i = ++_i) {
  x = rand() * size;
  y = rand() * size;
  w = rand() * 60 + 1;
  for (j = _j = 0, _ref = w * w; 0 <= _ref ? _j < _ref : _j > _ref; j = 0 <= _ref ? ++_j : --_j) {
    ang = rand() * Math.PI * 2;
    s = rand();
    cx = x + Math.sin(ang) * w * s;
    cy = y + Math.cos(ang) * w * s;
    c.fillRect(cx, cy, 1, 1);
  }
}

c.fillRect(10, 10, 100, 100);

pixels = c.getImageData(0, 0, size, size).data;

combinations = function(list) {
  var a, b, newlist, _k, _l, _ref1;
  newlist = [];
  for (a = _k = 0, _ref1 = list.length; 0 <= _ref1 ? _k < _ref1 : _k > _ref1; a = 0 <= _ref1 ? ++_k : --_k) {
    for (b = _l = 0; 0 <= a ? _l < a : _l > a; b = 0 <= a ? ++_l : --_l) {
      newlist.push([list[a], list[b]]);
    }
  }
  return newlist;
};

Math.max = function(a, b) {
  return (a > b ? a : b);
};

weightMerger = function(_arg, _arg1) {
  var a1, a2, amax, asum, bound, dist, dx, dy, h1, h2, maxh, maxw, maxx, maxy, minx, miny, w1, w2, waste, waste1, waste2, x1, x2, y1, y2;
  x1 = _arg[0], y1 = _arg[1], w1 = _arg[2], h1 = _arg[3], waste1 = _arg[4];
  x2 = _arg1[0], y2 = _arg1[1], w2 = _arg1[2], h2 = _arg1[3], waste2 = _arg1[4];
  minx = Math.min(x1, x2);
  miny = Math.min(y1, y2);
  maxx = Math.max(x1 + w1, x2 + w2);
  maxy = Math.max(y1 + h1, y2 + h2);
  maxw = maxx - minx;
  maxh = maxy - miny;
  a1 = w1 * h1;
  a2 = w2 * h2;
  asum = a1 + a2;
  amax = maxw * maxh;
  waste = waste1 + waste2 + Math.max(0, amax - asum);
  bound = [minx, miny, maxw, maxh, waste];
  dx = Math.max(x1, x2) - Math.min(x1 + w1, x2 + w2);
  dy = Math.max(y1, y2) - Math.min(y1 + h1, y2 + h2);
  dist = 0;
  if (dx < 0) {
    dist = Math.max(dy, 0);
  } else if (dy < 0) {
    dist = dx;
  } else {
    dist = Math.sqrt(dx * dx + dy * dy);
  }
  if (!((y1 + h1) < y2 || y1 > (y2 + h2) || (x1 + w1) < x2 || x1 > (x2 + w2))) {
    return [-1, bound];
  }
  if (dist < 20) {
    return [waste, bound];
  }
  return null;
};

getPixel = function(x, y) {
  return pixels[4 * (y * size + x) + 3] > 0;
};

smallBoundingBox = function(x, y) {
  var sched, xmax, xmin, ymax, ymin, _k, _l;
  xmin = 5;
  ymin = 5;
  xmax = -1;
  ymax = -1;
  sched = [[0, 0], [3, 3], [0, 1], [3, 2], [1, 0], [2, 3], [0, 2], [3, 1], [2, 0], [1, 3], [0, 3], [3, 0], [1, 1], [2, 2], [1, 2], [2, 1]];
  for (i = _k = 0; _k < 4; i = ++_k) {
    for (j = _l = 0; _l < 4; j = ++_l) {
      if ((xmin < i && i < xmax) && (ymin < j && j < ymax)) {
        continue;
      }
      if (getPixel(x + i, y + j)) {
        xmin = Math.min(xmin, i);
        xmax = Math.max(xmax, i);
        ymin = Math.min(ymin, j);
        ymax = Math.max(ymax, j);
      }
    }
  }
  if (ymax < 0) {
    return [];
  }
  return [[x + xmin, y + ymin, xmax - xmin, ymax - ymin, 0]];
};

divideQuadrants = function(x, y, w, h) {
  var a, b, bound, boundary, box, boxes, boxtmp, h1, h2, hh, hw, mx, my, pair, pairs, score, skipbox, sorted, start, w1, w2, waste1, waste2, weight, x1, x2, y1, y2, _k, _l, _len, _len1, _ref1;
  if (w === 4 && h === 4) {
    return smallBoundingBox(x, y);
  }
  hw = w >> 1;
  hh = h >> 1;
  mx = x + hw;
  my = y + hw;
  start = +(new Date);
  boxes = [].concat(divideQuadrants(x, y, hw, hh), divideQuadrants(mx, y, hw, hh), divideQuadrants(mx, my, hw, hh), divideQuadrants(x, my, hw, hh));
  c.strokeStyle = 'rgba(0,0,0,0.1)';
  c.strokeRect(x, y, w, h);
  c.strokeStyle = 'black';
  skipbox = [];
  if (w > 512) {
    boundary = 32;
    boxtmp = boxes;
    boxes = [];
    for (_k = 0, _len = boxtmp.length; _k < _len; _k++) {
      box = boxtmp[_k];
      x1 = box[0], y1 = box[1], w1 = box[2], h1 = box[3], waste1 = box[4];
      if (Math.abs(x1 - mx) < boundary || Math.abs(x1 + w1 - mx) < boundary || Math.abs(y1 - my) < boundary || Math.abs(y1 + h1 - my) < boundary) {
        boxes.push(box);
      } else {
        skipbox.push(box);
      }
    }
  }
  while (boxes.length > 1) {
    pairs = (function() {
      var _l, _len1, _ref1, _ref2, _results;
      _ref1 = combinations(boxes);
      _results = [];
      for (_l = 0, _len1 = _ref1.length; _l < _len1; _l++) {
        _ref2 = _ref1[_l], a = _ref2[0], b = _ref2[1];
        weight = weightMerger(a, b);
        if (weight) {
          _results.push(weight.concat([a, b]));
        } else {
          _results.push(null);
        }
      }
      return _results;
    })();
    pairs = (function() {
      var _l, _len1, _results;
      _results = [];
      for (_l = 0, _len1 = pairs.length; _l < _len1; _l++) {
        pair = pairs[_l];
        if (pair !== null) {
          _results.push(pair);
        }
      }
      return _results;
    })();
    if (pairs.length === 0) {
      break;
    }
    sorted = pairs.sort(function(a, b) {
      return a[0] - b[0];
    });
    _ref1 = sorted[0], score = _ref1[0], bound = _ref1[1], a = _ref1[2], b = _ref1[3];
    boxes = (function() {
      var _l, _len1, _results;
      _results = [];
      for (_l = 0, _len1 = boxes.length; _l < _len1; _l++) {
        box = boxes[_l];
        if (box !== a && box !== b) {
          _results.push(box);
        }
      }
      return _results;
    })();
    boxes.push(bound);
    x2 = bound[0], y2 = bound[1], w2 = bound[2], h2 = bound[3], waste2 = bound[4];
    boxtmp = skipbox;
    skipbox = [];
    for (_l = 0, _len1 = boxtmp.length; _l < _len1; _l++) {
      box = boxtmp[_l];
      x1 = box[0], y1 = box[1], w1 = box[2], h1 = box[3], waste1 = box[4];
      if (!((y1 + h1) < y2 || y1 > (y2 + h2) || (x1 + w1) < x2 || x1 > (x2 + w2))) {
        boxes.push(box);
      } else {
        skipbox.push(box);
      }
    }
  }
  return boxes.concat(skipbox);
};

reference = function(w, h) {
  var filled, _k, _l;
  filled = 0;
  for (x = _k = 0; 0 <= w ? _k < w : _k > w; x = 0 <= w ? ++_k : --_k) {
    for (y = _l = 0; 0 <= h ? _l < h : _l > h; y = 0 <= h ? ++_l : --_l) {
      if (pixels[4 * (y * size + x) + 3] > 0) {
        filled++;
      }
    }
  }
  return filled;
};

recursion = function(x, y, w, h) {
  var hh, hw;
  if (w === 1 && h === 1) {
    if (pixels[4 * (y * size + x) + 3] > 0) {
      return 1;
    } else {
      return 0;
    }
  }
  hw = w >> 1;
  hh = h >> 1;
  return recursion(x, y, hw, hh) + recursion(x + hw, y, hw, hh) + recursion(x + hw, y + hh, hw, hh) + recursion(x, y + hh, hw, hh);
};

basictree = function(x, y, w, h) {
  var boxes, hh, hw;
  if (w === 1 && h === 1) {
    if (pixels[4 * (y * size + x) + 3] > 0) {
      return [[x, y, 1, 1, 0]];
    } else {
      return [];
    }
  }
  hw = w >> 1;
  hh = h >> 1;
  boxes = [].concat(basictree(x, y, hw, hh), basictree(x + hw, y, hw, hh), basictree(x + hw, y + hh, hw, hh), basictree(x, y + hh, hw, hh));
  return boxes;
};

console.time("merge");

parts = divideQuadrants(0, 0, size, size);

console.timeEnd("merge");

c.strokeStyle = 'green';

c.lineWidth = 2;

for (_k = 0, _len = parts.length; _k < _len; _k++) {
  _ref1 = parts[_k], x = _ref1[0], y = _ref1[1], w = _ref1[2], h = _ref1[3], e = _ref1[4];
  c.strokeRect(x + 0.5, y + 0.5, w, h);
}

_ref2 = combinations(parts);
for (_l = 0, _len1 = _ref2.length; _l < _len1; _l++) {
  _ref3 = _ref2[_l], (_ref4 = _ref3[0], x1 = _ref4[0], y1 = _ref4[1], w1 = _ref4[2], h1 = _ref4[3], waste1 = _ref4[4]), (_ref5 = _ref3[1], x2 = _ref5[0], y2 = _ref5[1], w2 = _ref5[2], h2 = _ref5[3], waste2 = _ref5[4]);
  if (!((y1 + h1) < y2 || y1 > (y2 + h2) || (x1 + w1) < x2 || x1 > (x2 + w2))) {
    console.log('intersection');
  }
}
